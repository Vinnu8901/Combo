Adhyan POM Studio — Consolidated Phases (Previous vs Upgraded)

This document collects the requirements, prior implementation notes, and upgraded code for each phase derived from the chat. Each phase includes: Requirements, Previous (short), Upgraded code (representative), Explanation, and suggested next steps.

Note: Code blocks are provided as plain text for copy/paste. The 'copy to clipboard' button is not executable inside Word — use the code blocks directly or copy manually.

Phase 1 — Core helpers & xpathLiteral

Requirements:

Requirements: Robust xpath literal builder, label fetcher, skip/dedupe helpers.

Previous (short):

// Previous (simplified)

function xpathLiteral(s){ return '"' + s + '"'; }

function getLabelFor(el){ return el && el.textContent ? el.textContent.trim() : null; }

Upgraded (representative code):

// Upgraded (representative)

function xpathLiteral(s){

s = String(s);

if (s.indexOf('"') === -1) return '"' + s + '"';

if (s.indexOf("'") === -1) return "'" + s + "'";

const parts = s.split('"');

const out = [];

for (let i = 0; i < parts.length; i++){

if (parts[i] !== '') out.push('"' + parts[i].replace(/\\/g,'\\\\') + '"');

if (i < parts.length - 1) out.push('\'"\'');

}

return 'concat(' + out.join(',') + ')';

}

function getLabelFor(el){

try { if (typeof bestLabelFor === 'function') return bestLabelFor(el); } catch(e){}

const id = el && el.getAttribute ? el.getAttribute('id') : null;

if (id) {

const sel = 'label[for="' + id.replace(/([#.;,[\\]()>+~=:\"'\\])/g,'\\$1') + '"]';

const lab = (window.CURRENT_DOC || document).querySelector(sel);

if (lab && lab.textContent) return lab.textContent.trim();

}

const parentLabel = el && el.closest ? el.closest('label') : null;

if (parentLabel && parentLabel.textContent) return parentLabel.textContent.trim();

return null;

}

Explanation / What it does / Why upgrade:

Explanation: The upgraded xpathLiteral handles both single and double quotes by building a concat(...) expression when needed. getLabelFor defers to user-provided bestLabelFor and falls back to label[for] and closest label.

Suggested next improvements:

Add unit tests for each generator function.

Add telemetry/logging for failures (XPath eval errors).

Add UI tests to ensure picker overlay and highlight work across pages with frames.


Phase 2 — Collect candidate elements & shouldSkip

Requirements:

Requirements: Wide but safe selector set, early filtering for noise, de-duplication.

Previous (short):

// Previous (simplified)

function collectCandidateElements(doc){

return Array.from(doc.querySelectorAll('button,input,a'));

}

function shouldSkip(el){ return false; }

Upgraded (representative code):

// Upgraded (representative)

function isHiddenByInlineStyle(el){

const s = (el.getAttribute('style')||'').toLowerCase();

return /display\s*:\snone|visibility\s:\shidden|opacity\s:\s0|pointer-events\s:\s*none/.test(s);

}

function hasUsefulLabel(el){

if (el.getAttribute('aria-label')) return true;

if (el.getAttribute('placeholder')) return true;

if (el.getAttribute('name')) return true;

const t = (el.textContent||'').trim();

return t.length > 0;

}

function shouldSkip(el){

if(!el || el.nodeType !== 1) return true;

if(el.hasAttribute('hidden')) return true;

if(el.getAttribute('aria-hidden') === 'true') return true;

if(isHiddenByInlineStyle(el)) return true;

if(el.hasAttribute('disabled')) return true;

if(!hasUsefulLabel(el)) return true;

return false;

}

function collectCandidateElements(doc){

const basics = Array.from(doc.querySelectorAll([

'input:not([type="hidden"])','button','a','select','textarea',

'[role="button"]','[data-ctl]','[data-qa-locator]','lightning-input'

].join(',')));

let filtered = basics.filter(el => !shouldSkip(el));

const seen = new Set();

filtered = filtered.filter(el=>{

const key = (el.tagName + '|' + (el.id||'') + '|' + (el.getAttribute('name')||''));

if (seen.has(key)) return false;

seen.add(key);

return true;

});

return filtered;

}

Explanation / What it does / Why upgrade:

Explanation: The upgraded collector broadens selectors (framework-specific tags), filters noise early with shouldSkip, and de-duplicates by a signature. This reduces false positives and keeps the list manageable.

Suggested next improvements:

Add unit tests for each generator function.

Add telemetry/logging for failures (XPath eval errors).

Add UI tests to ensure picker overlay and highlight work across pages with frames.


Phase 3 — XPath generator family (basic, wildcards, axes, functions)

Requirements:

Requirements: Provide multiple XPath families and a 'best' chooser.

Previous (short):

// Previous (simplified)

function genBasicXPath(el){ return '//' + el.tagName.toLowerCase(); }

Upgraded (representative code):

// Upgraded (representative)

function genBasicXPath(el){

const tag = el.tagName.toLowerCase();

if(el.id) return '//*[@id=' + xpathLiteral(el.id) + ']';

const name = el.getAttribute('name');

if(name) return '//' + tag + '[@name=' + xpathLiteral(name) + ']';

const label = getLabelFor(el);

if(label) return '//' + tag + '[contains(normalize-space(.), ' + xpathLiteral(label.trim()) + ')]';

const cls = (el.getAttribute('class')||'').trim().split(/\s+/)[0];

if(cls) return '//' + tag + '[contains(concat(" ", normalize-space(@class), " "), ' + xpathLiteral(' ' + cls + ' ') + ')]';

const parent = el.parentElement;

if(!parent) return '//' + tag + '[1]';

const same = Array.from(parent.children).filter(x => x.tagName === el.tagName);

const idx = same.indexOf(el) + 1;

return genBasicXPath(parent) + '/' + tag + '[' + idx + ']';

}

Explanation / What it does / Why upgrade:

Explanation: Multiple generator functions give alternative locator strategies; bestXPath chooses the most reliable (Salesforce/LWC, Pega, axes, functions, wildcards, basic). This improves resilience across apps.

Suggested next improvements:

Add unit tests for each generator function.

Add telemetry/logging for failures (XPath eval errors).

Add UI tests to ensure picker overlay and highlight work across pages with frames.


Phase 4 — UI bridge: fillLocatorList and interactions

Requirements:

Requirements: Render locator rows, support copy/highlight, dynamic patterns, template toggle.

Previous (short):

// Previous (simplified)

function fillLocatorList(){ /* simple table */ }

Upgraded (representative code):

// Upgraded (representative)

function fillLocatorList(panel = 'basic'){

const data = Array.isArray(window.CURRENT_LOCATORS) ? window.CURRENT_LOCATORS : [];

// create container and toolbar if needed...

// build rows with checkboxes, value cell, and single-click copy+highlight behavior

// support template toggle and copy/download actions

// (see in-chat full renderer implementation)

}

Explanation / What it does / Why upgrade:

Explanation: The upgraded renderer is resilient to different shapes of CURRENT_LOCATORS, provides UI controls (select all, template toggle, copy/download) and wires per-row click to copy the value and run tryHighlight for xpaths.

Suggested next improvements:

Add unit tests for each generator function.

Add telemetry/logging for failures (XPath eval errors).

Add UI tests to ensure picker overlay and highlight work across pages with frames.


Phase 5 — Dynamic XPath picker & patterns

Requirements:

Requirements: On-page picker overlay to hover/click element and generate multiple parameterized xpath templates (%s).

Previous (short):

// Previous (simplified)

No picker implemented.

Upgraded (representative code):

// Upgraded (representative)

(function openDynamicPicker(){

// overlay with hover highlight and click-to-pick behavior

// generateTemplatesForElement(el) returns prioritized array of templates:

// e.g. id-based, data-attr, name, aria-label, exact-text, contains-text, class-based, positional fallback

})();

Explanation / What it does / Why upgrade:

Explanation: Picker lets user pick an element visually and immediately get multiple %s templates to test. It stores selection in toolbar and enables applying templates to selected locator rows.

Suggested next improvements:

Add unit tests for each generator function.

Add telemetry/logging for failures (XPath eval errors).

Add UI tests to ensure picker overlay and highlight work across pages with frames.


Phase 6 — Robust highlight across shadow DOM & iframes

Requirements:

Requirements: tryHighlightByXPath that searches document, shadow roots, and frames and transiently highlights element.

Previous (short):

// Previous (simplified)

function tryHighlight(xpath){ const node = document.evaluate(xpath,...); node.style.outline = '3px solid'; }

Upgraded (representative code):

// Upgraded (representative)

function tryHighlightByXPath(xpath){

// evaluate in main doc, then find in shadow roots via findInShadowRoots, and search iframes recursively via findInIframes

// transientHighlightElement applies boxShadow/outline, scrollIntoView, then restores styles after timeout

}

Explanation / What it does / Why upgrade:

Explanation: Frame and shadow DOM aware highlighter increases chance of highlighting elements inside web components or different frames.

Suggested next improvements:

Add unit tests for each generator function.

Add telemetry/logging for failures (XPath eval errors).

Add UI tests to ensure picker overlay and highlight work across pages with frames.


Phase 7 — Action candidate finder (findActionCandidates)

Requirements:

Requirements: Heuristic to find 'action' buttons (close/menu/etc.) and expose them as CURRENT_LOCATORS for quick pickup.

Previous (short):

// Previous (simplified)

No dedicated action candidate finder.

Upgraded (representative code):

// Upgraded (representative)

function findActionCandidates(){

// scans buttons/a/div/span, heuristics on text/title/aria-label and icon classes, returns list with basic/sf/pega xpaths and sets window.CURRENT_LOCATORS

}

Explanation / What it does / Why upgrade:

Explanation: This is useful for quickly finding close/menu/action controls on pages like modals or dynamic menus.

Suggested next improvements:

Add unit tests for each generator function.

Add telemetry/logging for failures (XPath eval errors).

Add UI tests to ensure picker overlay and highlight work across pages with frames.


Phase 8 — Artifact generator (ZIP multi-file exporter)

Requirements:

Requirements: Build a zip of language/framework test scaffolding from selected locators (Java Selenium, Playwright, etc.).

Previous (short):

// Previous (simplified)

Manual copy-paste of locators into a project.

Upgraded (representative code):

// Upgraded (representative)

function buildArtifactsFiles(options){

// normalize locators, then produce files map for Java (pom.xml, BaseTest.java, PageObject with @FindBy xpath fields, tests), JS, Playwright, etc.

}

async function downloadZipFromFiles(filesMap, zipName){

// uses JSZip to package and trigger download

}

Explanation / What it does / Why upgrade:

Explanation: Automates scaffolding; useful for demo tests or quick PoCs. Keep generated files minimal and allow user edits after download.

Suggested next improvements:

Add unit tests for each generator function.

Add telemetry/logging for failures (XPath eval errors).

Add UI tests to ensure picker overlay and highlight work across pages with frames.


Phase 9 — UI compatibility bridges & safe standalone dumps

Requirements:

Requirements: Provide drop-in fillers (printFillLocatorList, safe fillLocatorList) so the patch works even if original UI functions are absent.

Previous (short):

// Previous (simplified)

Application had a single monolithic renderer; failing if missing functions.

Upgraded (representative code):

// Upgraded (representative)

function printFillLocatorList(panel, containerId){ /* creates a standalone dump */ }

function fillLocatorList(panel){ /* robust, works with multiple CURRENT_LOCATORS shapes */ }

(function uiCompatBridge(){ window.extractAllLocators = function(){ /* uses collector + generators then sets CURRENT_LOCATORS and calls fillLocatorList */ }})();

Explanation / What it does / Why upgrade:

Explanation: Compatibility layers make the patch non-invasive — they don't require replacing whole app code and gracefully fall back.

Suggested next improvements:

Add unit tests for each generator function.

Add telemetry/logging for failures (XPath eval errors).

Add UI tests to ensure picker overlay and highlight work across pages with frames.





======R T M Ending======


<script>
/* =========================
   Helpers & State
========================= */
const $  = s => document.querySelector(s);
const $$ = s => Array.from(document.querySelectorAll(s));
const preview   = $('#preview');
const locList   = $('#locList');
const output    = $('#output');
const pasteBox  = $('#pasteBox');
const hiddenFile= $('#hiddenFile');
const toast     = $('#toast');

let CURRENT_HTML = '';
let CURRENT_DOC  = null;
let CURRENT_LOCATORS = [];    // [{id, tag, text, xpaths:{...}, css, playwright}]
let SELECTED_IDS = new Set(); // for export selection

/* =========================
   Small style polish (no layout change)
========================= */
/* Make chips look like buttons, keep same places */
const styleBtnish = document.createElement('style');
styleBtnish.textContent = `
  .chip{
    border-radius:10px; padding:8px 12px; background:#0f1420;
    border:1px solid #2b3748; cursor:pointer; color:#c7d3e5; font-weight:700;
    box-shadow:0 1px 0 rgba(0,0,0,.15)
  }
  .chip:hover{ background:#121926 }
  .chip.active{
    background:linear-gradient(180deg,#7c5cff,#5a48f0); color:#fff;
    border-color:#5b49f2; box-shadow:0 6px 18px rgba(90,72,240,.12)
  }
`;
document.head.appendChild(styleBtnish);

/* =========================
   Mode switch
========================= */
const modePOM = $('#modePOM');
const modeAPI = $('#modeAPI');
const apiPanel = $('#apiPanel');
modePOM?.addEventListener('click',()=>setMode('pom'));
modeAPI?.addEventListener('click',()=>setMode('api'));
function setMode(m){
  modePOM.classList.toggle('active', m==='pom');
  modeAPI.classList.toggle('active', m==='api');
  $('#pomLeftCard')?.classList.toggle('hidden', m!=='pom');
  $('#leftHead')?.classList.toggle('hidden', m!=='pom');
  apiPanel?.classList.toggle('hidden', m!=='api');
}

/* =========================
   Toast
========================= */
function showToast(msg){
  toast.textContent = msg;
  toast.classList.add('show');
  setTimeout(()=>toast.classList.remove('show'),1400);
}

/* =========================
   File open / paste / clear
========================= */
$('#btnOpenFile')?.addEventListener('click', ()=> hiddenFile.click());
hiddenFile?.addEventListener('change', e=>{
  const f=e.target.files[0]; if(!f) return;
  const reader=new FileReader();
  reader.onload = ev => { pasteBox.value = ev.target.result; renderPreview(); };
  reader.readAsText(f);
});
$('#btnPaste')?.addEventListener('click', async ()=>{
  try{
    const txt = await navigator.clipboard.readText();
    if(!txt) return showToast('Clipboard empty');
    pasteBox.value = txt; renderPreview();
  }catch(e){ showToast('Clipboard permission denied'); }
});
$('#btnClear')?.addEventListener('click', ()=>{
  pasteBox.value = '';
  preview.srcdoc = '<!doctype html><meta charset="utf-8"><body style="font-family:sans-serif"><h3>Preview cleared</h3></body>';
  CURRENT_HTML = ''; CURRENT_DOC = null; CURRENT_LOCATORS = []; SELECTED_IDS = new Set();
  locList.innerHTML = ''; output.value = '';
});

/* =========================
   Drag & Drop
========================= */
const dropZone = $('#dropZone');
if(dropZone){
  ['dragenter','dragover'].forEach(ev=>dropZone.addEventListener(ev,e=>{ e.preventDefault(); dropZone.style.borderColor='#5a48f0'; }));
  ['dragleave','drop'].forEach(ev=>dropZone.addEventListener(ev,e=>{ e.preventDefault(); dropZone.style.borderColor='#3a475a'; }));
  dropZone.addEventListener('drop', e=>{
    const f=e.dataTransfer.files?.[0]; if(!f) return;
    const reader=new FileReader();
    reader.onload = ev => { pasteBox.value = ev.target.result; renderPreview(); };
    reader.readAsText(f);
  });
}

/* =========================
   Render → extract
   (Light preview bg for visibility)
========================= */
$('#btnRender')?.addEventListener('click', renderPreview);
function renderPreview(){
  const html = (pasteBox.value||'').trim() || '<!doctype html><meta charset="utf-8"><body><h3>Paste HTML and click Render</h3></body>';
  CURRENT_HTML = html;
  const LIGHT_INJECT = `
    <style>
      html,body{ background:#ffffff !important; color:#0f172a !important; }
      *{ color-scheme: light !important; }
    </style>`;
  preview.srcdoc = `<!doctype html><meta charset="utf-8">${LIGHT_INJECT}${html}`;

  const parser = new DOMParser();
  CURRENT_DOC = parser.parseFromString(html, 'text/html');

  setTimeout(extractAllLocators, 50);
  showToast('Preview rendered');
}

/* =========================
   Tabs sync (Basic / Wildcards / Axes / Functions / SF / Pega / Dynamic)
========================= */
const leftHead = $('#leftHead');
if(leftHead && !leftHead.querySelector('[data-paneltab="dynamic"]')){
  const dyn = document.createElement('div');
  dyn.className = 'chip'; dyn.dataset.paneltab = 'dynamic'; dyn.textContent = 'Dynamic';
  leftHead.appendChild(dyn);
}
leftHead?.addEventListener('click', e=>{
  const chip = e.target.closest('.chip'); if(!chip) return;
  $$('.chip').forEach(c=>c.classList.remove('active'));
  chip.classList.add('active');
  fillLocatorList(chip.dataset.paneltab || 'basic');
});
$$('.side .btn[data-panel]').forEach(b=>b.addEventListener('click',()=>{
  $$('.chip').forEach(c=>c.classList.remove('active'));
  const sel = b.dataset.panel;
  const chip = $(`.chip[data-paneltab="${sel}"]`);
  if(chip){ chip.classList.add('active'); fillLocatorList(sel); }
  showToast(sel+' panel');
}));

/* =========================
   Locator Extraction Core
========================= */
function bestLabelFor(el){
  const txt = (el.getAttribute?.('aria-label') || el.getAttribute?.('title') || el.getAttribute?.('placeholder') || el.textContent || '').trim();
  return txt.replace(/\s+/g,' ').slice(0,80);
}
// SVG-aware basic XPath
function genBasicXPath(el){
  const isSVG = (typeof SVGElement!=='undefined') && (el instanceof SVGElement || el.ownerSVGElement!=null);
  const tag = el.tagName.toLowerCase();
  const tagExpr = isSVG ? `*[local-name()='${tag}']` : tag;
  if(el.id) return `//*[@id="${el.id}"]`;
  if(el.getAttribute && el.getAttribute('name')) return `//${tagExpr}[@name="${el.getAttribute('name')}"]`;
  const label = bestLabelFor(el);
  if(label) return `//${tagExpr}[contains(normalize-space(.),"${label.replace(/"/g,'\\"')}")]`;
  const cls = (el.getAttribute?.('class')||'').trim().split(/\s+/).filter(Boolean)[0];
  if(cls) return `//${tagExpr}[contains(@class,"${cls}")]`;
  const parent = el.parentElement || el.parentNode;
  if(!parent || parent.nodeType!==1) return `//${tagExpr}[1]`;
  const same = Array.from(parent.children||[]).filter(x=>x.tagName===el.tagName);
  const idx = same.indexOf(el)+1;
  return `(${genBasicXPath(parent)}/${tagExpr})[${idx}]`;
}
function genWildcardXPath(el){
  const tag=el.tagName.toLowerCase();
  const label = bestLabelFor(el);
  if(label) return `//*[contains(normalize-space(.),"${label.replace(/"/g,'\\"')}")]`;
  const name = el.getAttribute?.('name'); if(name) return `//${tag}[contains(@name,"${name}")]`;
  const id = el.id; if(id) return `//*[contains(@id,"${id}")]`;
  const cls = (el.getAttribute?.('class')||'').trim().split(/\s+/).find(Boolean); if(cls) return `//*[contains(@class,"${cls}")]`;
  return genBasicXPath(el);
}
function genAxesXPath(el){
  const tag = el.tagName.toLowerCase();
  const label = bestLabelFor(el);
  if(label) return `//${tag}[normalize-space(.)="${label.replace(/"/g,'\\"')}"] | //label[normalize-space(.)="${label.replace(/"/g,'\\"')}"]/following::${tag}[1]`;
  const parent = el.closest?.('[id],[name],[class]') || el.parentElement;
  if(parent && parent!==el){
    const pid = parent.id ? `//*[@id="${parent.id}"]` : genBasicXPath(parent);
    return `${pid}//${tag}[1]`;
  }
  return genBasicXPath(el);
}
function genFunctionXPath(el){
  const tag = el.tagName.toLowerCase();
  const label = bestLabelFor(el);
  if(label) return `//${tag}[contains(normalize-space(.),"${label.replace(/"/g,'\\"')}")]`;
  const ph = el.getAttribute?.('placeholder'); if(ph) return `//${tag}[starts-with(@placeholder,"${ph.split(' ')[0]}")]`;
  const aria = el.getAttribute?.('aria-label'); if(aria) return `//${tag}[normalize-space(@aria-label)="${aria.replace(/"/g,'\\"')}"]`;
  return genBasicXPath(el);
}
// Framework stubs (keep your specialized ones if you already have)
function genSalesforceXPath(el){ return genFunctionXPath(el); }
function genSalesforceSmartXPath(el){ return genFunctionXPath(el); }
function genPegaXPath(el){ return genFunctionXPath(el); }
function genPegaSmartXPath(el){ return genFunctionXPath(el); }
function genCSS(el){ return ''; }
function genPlaywright(el){ return ''; }

/* ========= NEW: Dynamic patterns (with %s) ========= */
function dynamicPatternsFor(el){
  const tag = el.tagName.toLowerCase();
  const text = bestLabelFor(el);
  const ph   = el.getAttribute?.('placeholder');
  const name = el.getAttribute?.('name');
  const type = el.getAttribute?.('type');
  const role = el.getAttribute?.('role');
  const patterns = [];

  // generic text match
  if(text) patterns.push(`//*[contains(normalize-space(.),"${text.replace(/"/g,'\\"')}")]`);

  if(tag==='button' || role==='button')
    patterns.push(`//button[contains(normalize-space(.),"%s")]`);

  if(tag==='a')
    patterns.push(`//a[contains(normalize-space(.),"%s")]`);

  if(tag==='input' && (!type || /text|email|search|password|tel|number/.test(type)))
    patterns.push(`//input[contains(@placeholder,"%s") or contains(@name,"%s")]`);

  if(tag==='input' && /checkbox/.test(type||''))
    patterns.push(`//input[@type="checkbox" and contains(@name,"%s")]`);

  if(tag==='input' && /radio/.test(type||''))
    patterns.push(`//input[@type="radio" and contains(@name,"%s")]`);

  if(tag==='select')
    patterns.push(`//select[contains(@name,"%s") or contains(@aria-label,"%s")]`);

  if(tag==='img')
    patterns.push(`//img[contains(@alt,"%s")]`);

  // safe fallbacks
  patterns.push(`//*[contains(@id,"%s")]`);
  patterns.push(`//*[@data-test-id="%s" or @data-testid="%s" or @data-id="%s"]`);

  // de-dup
  return [...new Set(patterns)];
}

/* =========================
   Collector
========================= */
function extractAllLocators(){
  if(!CURRENT_DOC){ locList.innerHTML=''; return; }
  const doc = CURRENT_DOC;

  const basics = Array.from(doc.querySelectorAll(
    'input,button,a,select,textarea,' +
    'span[role="button"],[role="button"],' +
    '[data-ctl],[data-qa-locator],' +
    '[data-aura-class],[data-aura-rendered-by],[data-key],[data-id],' +
    '*[class*="slds-"]'
  ));
  const lwc = Array.from(doc.querySelectorAll([
    'lightning-input','lightning-button','lightning-combobox','lightning-textarea',
    'lightning-record-edit-form','lightning-tab','lightning-input-field','lightning-formatted-text'
  ].join(',')));
  const svg = Array.from(doc.querySelectorAll('svg, svg *'));
  const all = [...new Set([...basics, ...lwc, ...svg])];

  const sfDetected   = !!doc.querySelector('*[data-aura-rendered-by], *[class*="slds-"]');
  const pegaDetected = !!doc.querySelector('[data-ctl],span[data-ctl]');

  CURRENT_LOCATORS = all.map((el,idx)=>{
    const tag = el.tagName.toLowerCase();
    const label = bestLabelFor(el);
    const x = {
      basic:     genBasicXPath(el),
      wildcards: genWildcardXPath(el),
      axes:      genAxesXPath(el),
      functions: genFunctionXPath(el),
      sf:        genSalesforceXPath(el) || '',
      sfsmart:   genSalesforceSmartXPath(el) || '',
      pega:      genPegaXPath(el) || '',
      pegasmart: genPegaSmartXPath(el) || ''
    };
    return {
      id: `E${idx+1}`,
      tag, text: label,
      framework: pegaDetected ? 'Pega+' : (sfDetected ? 'Salesforce+' : ''),
      xpaths: x,
      dynamic: dynamicPatternsFor(el),
      playwright: '',
      css: ''
    };
  });

  fillLocatorList('basic');
  showToast(`Extracted ${CURRENT_LOCATORS.length} elements`);
}

/* =========================
   Locator List (copy+highlight on click)
========================= */
function fillLocatorList(panel='basic'){
  locList.innerHTML = '';
  if(!CURRENT_LOCATORS.length) return;

  CURRENT_LOCATORS.forEach(loc=>{
    let value = (loc.xpaths?.[panel]) || loc.xpaths.basic;
    if(panel==='sf'   && loc.xpaths.sfsmart)   value = loc.xpaths.sfsmart   || loc.xpaths.sf;
    if(panel==='pega' && loc.xpaths.pegasmart) value = loc.xpaths.pegasmart || loc.xpaths.pega;
    const isDynamic = panel==='dynamic';

    const row = document.createElement('div');
    row.className = 'loc-row';
    row.innerHTML = `
      <input type="checkbox" class="sel" data-id="${loc.id}" style="margin-right:6px" ${SELECTED_IDS.has(loc.id)?'checked':''} />
      <div style="display:flex;align-items:center;gap:8px;min-width:0;flex:1">
        <span class="badge">${(loc.framework||'').trim() || loc.tag}</span>
        <div style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:40ch">${loc.text || '(no text)'}</div>
      </div>
      <div class="mono val" style="flex:2;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${ isDynamic ? (loc.dynamic[0]||'') : (value || loc.css || loc.playwright || '') }</div>
      <div class="act">
        ${ isDynamic ? `<select class="dynSel" style="background:#0f1420;border:1px solid #2b3748;border-radius:8px;padding:4px 6px"></select>` : '' }
        <button class="btn" style="width:auto;padding:4px 8px" data-action="copy">Copy</button>
        <button class="btn" style="width:auto;padding:4px 8px" data-action="highlight">Highlight</button>
      </div>
    `;

    // Populate dynamic list (if panel is Dynamic)
    if(isDynamic){
      const sel = row.querySelector('.dynSel');
      (loc.dynamic||[]).forEach(p=>{
        const opt = document.createElement('option');
        opt.textContent = p; opt.value = p; sel.appendChild(opt);
      });
      sel?.addEventListener('change', ()=>{
        row.querySelector('.val').textContent = sel.value;
      });
    }

    // SINGLE CLICK on value => Copy + Highlight
    const valEl = row.querySelector('.val');
    valEl.addEventListener('click', e=>{
      e.stopPropagation();
      const text = valEl.textContent.trim();
      if(!text) return;
      navigator.clipboard.writeText(text).then(()=>showToast('Copied'));
      // try to highlight if it's XPath or CSS
      if(/^(\(?\/\/|\.\/\/|\/\/|\(\s*\/\/)/.test(text)) tryHighlight(text, null);
      else tryHighlight(null, text);
    });

    // Buttons
    row.querySelector('[data-action="copy"]').addEventListener('click', e=>{
      e.stopPropagation();
      const text = row.querySelector('.val').textContent.trim();
      if(!text) return;
      navigator.clipboard.writeText(text).then(()=>showToast('Copied'));
    });
    row.querySelector('[data-action="highlight"]').addEventListener('click', e=>{
      e.stopPropagation();
      const text = row.querySelector('.val').textContent.trim();
      if(/^(\(?\/\/|\.\/\/|\/\/|\(\s*\/\/)/.test(text)) tryHighlight(text, null);
      else tryHighlight(null, text);
    });

    // Selection
    row.querySelector('input.sel').addEventListener('change', ev=>{
      if(ev.target.checked) SELECTED_IDS.add(loc.id); else SELECTED_IDS.delete(loc.id);
    });

    locList.appendChild(row);
  });
}

/* =========================
   Highlight helpers
========================= */
function findByXPathInIframe(xpath){
  try{
    const doc = preview.contentDocument || preview.contentWindow.document;
    const iter = doc.evaluate(xpath, doc, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE, null);
    return iter.iterateNext();
  }catch(e){ return null; }
}
function highlightElementInIframe(el){
  if(!el) return;
  const old = el.style.outline;
  el.scrollIntoView({behavior:'smooth', block:'center', inline:'center'});
  el.style.outline = '2px solid #7c5cff';
  setTimeout(()=>{ el.style.outline = old; }, 1000);
}
function tryHighlight(xpath, css){
  if(xpath){
    const el = findByXPathInIframe(xpath);
    if(el){ highlightElementInIframe(el); return; }
  }
  if(css){
    try{
      const doc = preview.contentDocument || preview.contentWindow.document;
      const el = doc.querySelector(css);
      if(el) highlightElementInIframe(el);
    }catch(e){}
  }
}

/* =========================
   Export (selected/all)
========================= */
$('#btnExport')?.addEventListener('click', ()=>{
  if(!CURRENT_LOCATORS.length) return showToast('Nothing to export');
  const chosen = SELECTED_IDS.size ? CURRENT_LOCATORS.filter(l=>SELECTED_IDS.has(l.id)) : CURRENT_LOCATORS;
  const lines = [];
  lines.push('// Export — locators with basic checks');
  chosen.forEach(l=>{
    const best = l.xpaths.sfsmart||l.xpaths.sf||l.xpaths.pegasmart||l.xpaths.pega||l.xpaths.functions||l.xpaths.wildcards||l.xpaths.axes||l.xpaths.basic;
    lines.push(`// ${l.id} — <${l.tag}> — ${l.text}`);
    lines.push(`XPath (best): ${best}`);
    lines.push(`XPath (basic): ${l.xpaths.basic}`);
    lines.push(`XPath (wildcards): ${l.xpaths.wildcards}`);
    lines.push(`XPath (axes): ${l.xpaths.axes}`);
    lines.push(`XPath (functions): ${l.xpaths.functions}`);
    lines.push(`XPath (salesforce): ${l.xpaths.sf}`);
    lines.push(`XPath (pega): ${l.xpaths.pega}`);
    if(l.dynamic?.length){ lines.push('Dynamic patterns:'); l.dynamic.forEach(p=>lines.push('  - '+p)); }
    lines.push('');
  });
  const blob = new Blob([lines.join('\\n')], {type:'text/plain'});
  downloadBlob(blob, SELECTED_IDS.size? 'locators_selected.txt' : 'locators_export.txt');
  output.value = lines.join('\\n');
  showToast(SELECTED_IDS.size? 'Exported selected' : 'Exported');
});

/* =========================
   POM generator (kept minimal & working)
========================= */
$('#btnGenPOM')?.addEventListener('click', ()=>{
  if(!CURRENT_LOCATORS.length) return showToast('Render & extract first');
  const fw     = $('.sw[data-fw].active')?.dataset.fw || 'selenium';
  const runner = $('.sw[data-runner].active')?.dataset.runner || 'testng';
  const lang   = $('.sw[data-lang].active')?.dataset.lang || 'java';
  const res = buildArtifacts({fw, runner, lang, locs: CURRENT_LOCATORS});
  output.value = `// ===== POM =====\\n${res.pom}\\n\\n// ===== Steps =====\\n${res.steps}`;
  showToast('POM + Steps generated');
});

function buildArtifacts({fw, runner, lang, locs}){
  if(lang==='java'){
    if(fw==='selenium') return javaSeleniumArtifacts(runner, locs);
    else return javaPlaywrightArtifacts(runner, locs);
  }
  if(lang==='javascript') return jsPlaywrightArtifacts(locs);
  if(lang==='typescript') return tsPlaywrightArtifacts(locs);
  if(lang==='python')     return pyPlaywrightArtifacts(locs);
  return {pom:'// Unsupported', steps:''};
}
function javaSeleniumArtifacts(runner, locs){
  const pick = l => (l.xpaths.sfsmart||l.xpaths.sf||l.xpaths.pegasmart||l.xpaths.pega||l.xpaths.functions||l.xpaths.wildcards||l.xpaths.axes||l.xpaths.basic).replace(/"/g,'\\"');
  const fields = locs.map((l,i)=>`  @FindBy(xpath = "${pick(l)}")\n  private WebElement el${i+1};`).join('\n\n');
  const actions= locs.map((l,i)=>`  public void clickEl${i+1}(){ ensureClickable(el${i+1}); el${i+1}.click(); }`).join('\n');
  const waits  = `
  private WebDriver driver;
  private WebDriverWait wait;
  public SamplePage(WebDriver driver){
    this.driver = driver;
    PageFactory.initElements(driver, this);
    this.wait = new WebDriverWait(driver, Duration.ofSeconds(10));
  }
  private void ensureVisible(WebElement e){ wait.until(ExpectedConditions.visibilityOf(e)); }
  private void ensureClickable(WebElement e){ wait.until(ExpectedConditions.elementToBeClickable(e)); }`;
  const pom = `import org.openqa.selenium.*; 
import org.openqa.selenium.support.FindBy;
import org.openqa.selenium.support.PageFactory;
import org.openqa.selenium.support.ui.*;
import java.time.Duration;

public class SamplePage {
${fields}

${waits}

${actions}
}
`;
  const steps = (runner==='cucumber')
    ? `import io.cucumber.java.en.*; import org.openqa.selenium.*;\npublic class Steps {\n  private WebDriver driver; private SamplePage page;\n  @Given("open") public void open(){ /* init */ page = new SamplePage(driver); }\n  @When("click first") public void c1(){ page.clickEl1(); }\n  @Then("see") public void see(){ /* assert */ }\n}\n`
    : `import org.openqa.selenium.*; import org.testng.annotations.*;\npublic class TestSample {\n  private WebDriver driver; private SamplePage page;\n  @BeforeClass public void setup(){ /* init driver */ page = new SamplePage(driver); }\n  @Test public void t1(){ page.clickEl1(); }\n  @AfterClass public void cleanup(){ if(driver!=null) driver.quit(); }\n}\n`;
  return {pom, steps};
}
function javaPlaywrightArtifacts(runner, locs){
  const fields = locs.map((l,i)=>`  private Locator el${i+1};`).join('\n');
  const init   = locs.map((l,i)=>`    el${i+1} = page.locator("${(l.playwright||'').replace(/"/g,'\\"') || (l.xpaths.basic? `xpath=${l.xpaths.basic.replace(/"/g,'\\"')}` : 'css=*')}");`).join('\n');
  const actions= locs.map((l,i)=>`  public void clickEl${i+1}(){ el${i+1}.click(); }`).join('\n');
  const pom = `import com.microsoft.playwright.*;\npublic class PwPage {\n  private Page page;\n${fields}\n  public PwPage(Page page){\n    this.page = page;\n${init}\n  }\n${actions}\n}\n`;
  const steps = `// create BrowserType.LaunchOptions etc., then new PwPage(page) and call actions`;
  return {pom, steps};
}
function jsPlaywrightArtifacts(locs){
  const fields = locs.map((l,i)=>`  const el${i+1} = page.locator(\`${l.playwright || (l.xpaths.basic? 'xpath=' + l.xpaths.basic : 'css=*')}\`);`).join('\n');
  const pom = `// JS Playwright sample\nmodule.exports.test = async ({ page }) => {\n${fields}\n  await el1.click();\n};\n`;
  return {pom, steps:''};
}
function tsPlaywrightArtifacts(locs){
  const fields = locs.map((l,i)=>`  const el${i+1} = page.locator(\`${l.playwright || (l.xpaths.basic? 'xpath=' + l.xpaths.basic : 'css=*')}\`);`).join('\n');
  const pom = `// TS Playwright sample\nexport async function test(page: import('@playwright/test').Page){\n${fields}\n  await el1.click();\n}\n`;
  return {pom, steps:''};
}
function pyPlaywrightArtifacts(locs){
  const fields = locs.map((l,i)=>`    el${i+1} = page.locator("${l.playwright || (l.xpaths.basic? 'xpath=' + l.xpaths.basic : 'css=*')}")`).join('\n');
  const pom = `# Python Playwright sample\ndef test_example(page):\n${fields}\n    el1.click()\n`;
  return {pom, steps:''};
}

/* =========================
   API Studio (minimal)
========================= */
$('#btnGenerateApi')?.addEventListener('click', ()=>{
  const method = $('#apiMethod')?.value || 'GET';
  const url    = $('#apiUrl')?.value || '';
  const headers= $('#apiHeaders')?.value || '{}';
  const body   = $('#apiBody')?.value || 'null';
  const code = `// RestAssured\ngiven().headers(${headers}).body(${body}).when().${method.toLowerCase()}("${url}").then().statusCode(200);`;
  $('#apiCode').value = code;
  showToast('API code generated');
});

/* =========================
   Utils
========================= */
function downloadBlob(blob, filename){
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = filename;
  document.body.appendChild(a); a.click();
  setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
}

setMode('pom'); // default
</script>


///////////////////)/


<script>
/* =========================
   Helpers & State
========================= */
const $  = s => document.querySelector(s);
const $$ = s => Array.from(document.querySelectorAll(s));
const preview  = $('#preview');
const locList  = $('#locList');
const output   = $('#output');
const pasteBox = $('#pasteBox');
const hiddenFile = $('#hiddenFile');
const toast    = $('#toast');

let CURRENT_HTML = '';
let CURRENT_DOC  = null;
let CURRENT_LOCATORS = [];   // [{id, tag, text, xpaths:{...}, css, playwright}]
let SELECTED_IDS = new Set();// selected rows

/* =========================
   UI: Mode switching
========================= */
const modePOM = $('#modePOM');
const modeAPI = $('#modeAPI');
const apiPanel = $('#apiPanel');
modePOM?.addEventListener('click',()=>setMode('pom'));
modeAPI?.addEventListener('click',()=>setMode('api'));

function setMode(m){
  modePOM.classList.toggle('active', m==='pom');
  modeAPI.classList.toggle('active', m==='api');
  $('#pomLeftCard')?.classList.toggle('hidden', m!=='pom');
  $('#leftHead')?.classList.toggle('hidden', m!=='pom');
  apiPanel?.classList.toggle('hidden', m!=='api');
}

/* =========================
   Toast
========================= */
function showToast(msg){
  toast.textContent = msg;
  toast.classList.add('show');
  setTimeout(()=>toast.classList.remove('show'),1400);
}

/* =========================
   File open / paste / clear
========================= */
$('#btnOpenFile')?.addEventListener('click', ()=> hiddenFile.click());
hiddenFile?.addEventListener('change', e=>{
  const f=e.target.files[0]; if(!f) return;
  const reader=new FileReader();
  reader.onload = ev => { pasteBox.value = ev.target.result; renderPreview(); };
  reader.readAsText(f);
});

$('#btnPaste')?.addEventListener('click', async ()=>{
  try{
    const txt = await navigator.clipboard.readText();
    if(!txt) return showToast('Clipboard empty');
    pasteBox.value = txt; renderPreview();
  }catch(e){ showToast('Clipboard permission denied'); }
});

$('#btnClear')?.addEventListener('click', ()=>{
  pasteBox.value = '';
  preview.srcdoc = '<body style="font-family:sans-serif"><h3>Preview cleared</h3></body>';
  CURRENT_HTML = ''; CURRENT_DOC = null; CURRENT_LOCATORS = []; SELECTED_IDS = new Set();
  locList.innerHTML = ''; output.value = '';
});

/* =========================
   Drag & Drop to preview area
========================= */
const dropZone = $('#dropZone');
if(dropZone){
  ['dragenter','dragover'].forEach(ev=>dropZone.addEventListener(ev,e=>{ e.preventDefault(); dropZone.style.borderColor='#5a48f0'; }));
  ['dragleave','drop'].forEach(ev=>dropZone.addEventListener(ev,e=>{ e.preventDefault(); dropZone.style.borderColor='#3a475a'; }));
  dropZone.addEventListener('drop', e=>{
    const f=e.dataTransfer.files?.[0]; if(!f) return;
    const reader=new FileReader();
    reader.onload = ev => { pasteBox.value = ev.target.result; renderPreview(); };
    reader.readAsText(f);
  });
}

/* =========================
   Render → extract
========================= */
$('#btnRender')?.addEventListener('click', renderPreview);
function renderPreview(){
  const html = pasteBox.value?.trim() || '<!doctype html><meta charset="utf-8"><body><h3>Paste HTML and click Render</h3></body>';
  CURRENT_HTML = html;
  preview.srcdoc = html;

  const parser = new DOMParser();
  CURRENT_DOC = parser.parseFromString(html, 'text/html');

  setTimeout(extractAllLocators, 50);
  showToast('Preview rendered');
}

/* =========================
   Locator Panels: tab + sidebar sync
========================= */
const leftHead = $('#leftHead');
leftHead?.addEventListener('click', e=>{
  const chip = e.target.closest('.chip'); if(!chip) return;
  $$('.chip').forEach(c=>c.classList.remove('active'));
  chip.classList.add('active');
  fillLocatorList(chip.dataset.paneltab || 'basic');
});
$$('.side .btn[data-panel]').forEach(b=>b.addEventListener('click',()=>{
  $$('.chip').forEach(c=>c.classList.remove('active'));
  const sel = b.dataset.panel;
  const chip = $(`.chip[data-paneltab="${sel}"]`);
  if(chip){ chip.classList.add('active'); fillLocatorList(sel); }
  showToast(sel+' panel');
}));

/* =========================
   Locator Extraction Core
========================= */
function bestLabelFor(el){
  const txt = (el.getAttribute?.('aria-label') || el.getAttribute?.('title') || el.getAttribute?.('placeholder') || el.textContent || '').trim();
  return txt.replace(/\s+/g,' ').slice(0,80);
}

// SVG-aware basic XPath
function genBasicXPath(el){
  const isSVG = (typeof SVGElement!=='undefined') && (el instanceof SVGElement || el.ownerSVGElement!=null);
  const tag = el.tagName.toLowerCase();
  const tagExpr = isSVG ? `*[local-name()='${tag}']` : tag;
  if(el.id) return `//*[@id="${el.id}"]`;
  if(el.getAttribute && el.getAttribute('name')) return `//${tagExpr}[@name="${el.getAttribute('name')}"]`;
  const label = bestLabelFor(el);
  if(label) return `//${tagExpr}[contains(normalize-space(.),"${label.replace(/"/g,'\\"')}")]`;
  const cls = (el.getAttribute?.('class')||'').trim().split(/\s+/).filter(Boolean)[0];
  if(cls) return `//${tagExpr}[contains(@class,"${cls}")]`;
  const parent = el.parentElement || el.parentNode;
  if(!parent || parent.nodeType!==1) return `//${tagExpr}[1]`;
  const same = Array.from(parent.children||[]).filter(x=>x.tagName===el.tagName);
  const idx = same.indexOf(el)+1;
  return `(${genBasicXPath(parent)}/${tagExpr})[${idx}]`;
}
function genWildcardXPath(el){
  const tag=el.tagName.toLowerCase();
  const label = bestLabelFor(el);
  if(label) return `//*[contains(normalize-space(.),"${label.replace(/"/g,'\\"')}")]`;
  const name = el.getAttribute?.('name'); if(name) return `//${tag}[contains(@name,"${name}")]`;
  const id = el.id; if(id) return `//*[contains(@id,"${id}")]`;
  const cls = (el.getAttribute?.('class')||'').trim().split(/\s+/).find(Boolean); if(cls) return `//*[contains(@class,"${cls}")]`;
  return genBasicXPath(el);
}
function genAxesXPath(el){
  const tag = el.tagName.toLowerCase();
  const label = bestLabelFor(el);
  if(label) return `//${tag}[normalize-space(.)="${label.replace(/"/g,'\\"')}"] | //label[normalize-space(.)="${label.replace(/"/g,'\\"')}"]/following::${tag}[1]`;
  const parent = el.closest?.('[id],[name],[class]') || el.parentElement;
  if(parent && parent!==el){
    const pid = parent.id ? `//*[@id="${parent.id}"]` : genBasicXPath(parent);
    return `${pid}//${tag}[1]`;
  }
  return genBasicXPath(el);
}
function genFunctionXPath(el){
  const tag = el.tagName.toLowerCase();
  const label = bestLabelFor(el);
  if(label) return `//${tag}[contains(normalize-space(.),"${label.replace(/"/g,'\\"')}")]`;
  const ph = el.getAttribute?.('placeholder'); if(ph) return `//${tag}[starts-with(@placeholder,"${ph.split(' ')[0]}")]`;
  const aria = el.getAttribute?.('aria-label'); if(aria) return `//${tag}[normalize-space(@aria-label)="${aria.replace(/"/g,'\\"')}"]`;
  return genBasicXPath(el);
}

// Stubs for framework-specific generators (keep yours if already present)
function genSalesforceXPath(el){ return genFunctionXPath(el); }
function genSalesforceSmartXPath(el){ return genFunctionXPath(el); }
function genPegaXPath(el){ return genFunctionXPath(el); }
function genPegaSmartXPath(el){ return genFunctionXPath(el); }
function genCSS(el){ try{ return el?.selectorText || ''; }catch(e){ return ''; } }
function genPlaywright(el){ return ''; }

// Collector
function extractAllLocators(){
  if(!CURRENT_DOC){ locList.innerHTML=''; return; }
  const doc = CURRENT_DOC;

  let elements = [];
  // fallback collector
  const basics = Array.from(doc.querySelectorAll(
    'input,button,a,select,textarea,' +
    'span[role="button"],[role="button"],' +
    '[data-ctl],[data-qa-locator],' +
    '[data-aura-class],[data-aura-rendered-by],[data-key],[data-id],' +
    '*[class*="slds-"]'
  ));
  const lwc = Array.from(doc.querySelectorAll([
    'lightning-input','lightning-button','lightning-combobox','lightning-textarea',
    'lightning-record-edit-form','lightning-tab','lightning-input-field','lightning-formatted-text'
  ].join(',')));
  const svg = Array.from(doc.querySelectorAll('svg, svg *'));
  const all = [...new Set([...basics, ...lwc, ...svg])];

  elements = all.filter(el=>{
    const style = (el.getAttribute?.('style')||'').toLowerCase();
    if(style.includes('display:none') || style.includes('visibility:hidden')) return false;
    return true;
  });

  const sfDetected   = !!doc.querySelector('*[data-aura-rendered-by], *[class*="slds-"]');
  const pegaDetected = !!doc.querySelector('[data-ctl],span[data-ctl]');

  CURRENT_LOCATORS = elements.map((el,idx)=>{
    const tag = el.tagName.toLowerCase();
    const label = bestLabelFor(el);
    const x = {
      basic:     genBasicXPath(el),
      wildcards: genWildcardXPath(el),
      axes:      genAxesXPath(el),
      functions: genFunctionXPath(el),
      sf:        genSalesforceXPath(el) || '',
      sfsmart:   genSalesforceSmartXPath(el) || '',
      pega:      genPegaXPath(el) || '',
      pegasmart: genPegaSmartXPath(el) || ''
    };
    return {
      id: `E${idx+1}`,
      tag,
      text: label,
      framework: pegaDetected ? 'Pega+' : (sfDetected ? 'Salesforce+' : ''),
      xpaths: x,
      playwright: genPlaywright(el) || '',
      css: ''
    };
  });

  fillLocatorList('basic');
  showToast(`Extracted ${CURRENT_LOCATORS.length} elements`);
}

/* =========================
   Locator List (expand/collapse + selection + param)
========================= */
function fillLocatorList(panel='basic'){
  locList.innerHTML = '';
  if(!CURRENT_LOCATORS.length) return;

  CURRENT_LOCATORS.forEach(loc=>{
    let value = (loc.xpaths?.[panel]) || loc.xpaths.basic;
    if(panel==='sf'   && loc.xpaths.sfsmart)   value = loc.xpaths.sfsmart   || loc.xpaths.sf;
    if(panel==='pega' && loc.xpaths.pegasmart) value = loc.xpaths.pegasmart || loc.xpaths.pega;

    const row = document.createElement('div');
    row.className = 'loc-row';
    row.innerHTML = `
      <input type="checkbox" class="sel" data-id="${loc.id}" style="margin-right:6px" ${SELECTED_IDS.has(loc.id)?'checked':''} />
      <div style="display:flex;align-items:center;gap:8px;min-width:0;flex:1">
        <span class="badge">${(loc.framework||'').trim() || loc.tag}</span>
        <div style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:40ch">${loc.text || '(no text)'}</div>
      </div>
      <div class="mono val" style="flex:2;white-space:nowrap;overflow:hidden;text-overflow:ellipsis" title="${(value||loc.css||loc.playwright||'').replace(/"/g,'&quot;')}">${value || loc.css || loc.playwright || ''}</div>
      <div class="act">
        <button class="btn" style="width:auto;padding:4px 8px" data-action="copy">Copy</button>
        <button class="btn" style="width:auto;padding:4px 8px" data-action="highlight">Highlight</button>
        <button class="btn" style="width:auto;padding:4px 8px" data-action="param">Param</button>
      </div>
    `;

    // 1) default: row click = copy
    row.addEventListener('click', e=>{
      if(e.target.closest('button') || e.target.closest('input')) return;
      const toCopy = value || loc.css || loc.playwright || '';
      if(!toCopy) return;
      navigator.clipboard.writeText(toCopy).then(()=>showToast('Copied'));
    });

    // 2) double-tap/dblclick value area = expand/collapse (see full)
    const valEl = row.querySelector('.val');
    let tapT=0;
    valEl.addEventListener('click', ev=>{
      const now = Date.now();
      if(now-tapT<300){ // double tap
        ev.stopPropagation();
        const expanded = valEl.style.whiteSpace==='normal';
        valEl.style.whiteSpace = expanded?'nowrap':'normal';
        valEl.style.overflow = expanded?'hidden':'visible';
        valEl.style.textOverflow = expanded?'ellipsis':'clip';
      }
      tapT = now;
    });

    // 3) buttons
    row.querySelector('[data-action="copy"]').addEventListener('click', e=>{
      e.stopPropagation();
      const toCopy = value || loc.css || loc.playwright || '';
      if(!toCopy) return;
      navigator.clipboard.writeText(toCopy).then(()=>showToast('Copied'));
    });
    row.querySelector('[data-action="highlight"]').addEventListener('click', e=>{
      e.stopPropagation();
      tryHighlight(loc.xpaths.basic, loc.css);
    });
    row.querySelector('[data-action="param"]').addEventListener('click', e=>{
      e.stopPropagation();
      let xp = (loc.xpaths && (loc.xpaths.sfsmart||loc.xpaths.sf||loc.xpaths.pegasmart||loc.xpaths.pega||loc.xpaths.functions||loc.xpaths.wildcards||loc.xpaths.axes||loc.xpaths.basic)) || '';
      if(!xp){ alert('No XPath available'); return; }
      xp = xp.replace(/(=\s*["'])([^"']+)(["'])/, `$1%s$3`); // first quoted literal → %s
      navigator.clipboard.writeText(xp).then(()=>showToast('Param XPath copied'));
    });

    // 4) selection
    row.querySelector('input.sel').addEventListener('change', ev=>{
      if(ev.target.checked) SELECTED_IDS.add(loc.id); else SELECTED_IDS.delete(loc.id);
    });

    locList.appendChild(row);
  });
}

/* =========================
   Preview highlight helpers
========================= */
function findByXPathInIframe(xpath){
  try{
    const doc = preview.contentDocument || preview.contentWindow.document;
    const iter = doc.evaluate(xpath, doc, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE, null);
    return iter.iterateNext();
  }catch(e){ return null; }
}
function highlightElementInIframe(el){
  if(!el) return;
  const old = el.style.outline;
  el.scrollIntoView({behavior:'smooth', block:'center', inline:'center'});
  el.style.outline = '2px solid #7c5cff';
  setTimeout(()=>{ el.style.outline = old; }, 1000);
}
function tryHighlight(xpath, css){
  const looksXPath = !!xpath && (/^(\(?\/\/|\.\/\/|\/\/|\(\s*\/\/)/.test(xpath));
  if(looksXPath){ const el = findByXPathInIframe(xpath); if(el){ highlightElementInIframe(el); return; } }
  try{ const doc = preview.contentDocument || preview.contentWindow.document; const el = doc.querySelector(css); if(el) highlightElementInIframe(el); }catch(e){}
}

/* =========================
   Export (locators + checks)
========================= */
$('#btnExport')?.addEventListener('click', ()=>{
  if(!CURRENT_LOCATORS.length) return showToast('Nothing to export');
  const chosen = SELECTED_IDS.size ? CURRENT_LOCATORS.filter(l=>SELECTED_IDS.has(l.id)) : CURRENT_LOCATORS;
  const lines = [];
  lines.push('// Export — locators with basic checks');
  chosen.forEach(l=>{
    lines.push(`// ${l.id} — <${l.tag}> — ${l.text}`);
    lines.push(`XPath (best): ${l.xpaths.sfsmart||l.xpaths.sf||l.xpaths.pegasmart||l.xpaths.pega||l.xpaths.functions||l.xpaths.wildcards||l.xpaths.axes||l.xpaths.basic}`);
    lines.push(`XPath (basic): ${l.xpaths.basic}`);
    lines.push(`XPath (wildcards): ${l.xpaths.wildcards}`);
    lines.push(`XPath (axes): ${l.xpaths.axes}`);
    lines.push(`XPath (functions): ${l.xpaths.functions}`);
    lines.push(`XPath (salesforce): ${l.xpaths.sf}`);
    lines.push(`XPath (pega): ${l.xpaths.pega}`);
    lines.push(`CSS: ${l.css}`);
    lines.push(`Playwright: ${l.playwright}`);
    lines.push('Checks:');
    lines.push('  - visible');
    lines.push('  - enabled');
    lines.push('  - clickable');
    lines.push('');
  });
  const blob = new Blob([lines.join('\\n')], {type:'text/plain'});
  downloadBlob(blob, SELECTED_IDS.size? 'locators_selected.txt' : 'locators_export.txt');
  output.value = lines.join('\\n');
  showToast(SELECTED_IDS.size? 'Exported selected' : 'Exported');
});

/* =========================
   Generate POM + Steps (works)
========================= */
$('#btnGenPOM')?.addEventListener('click', ()=>{
  if(!CURRENT_LOCATORS.length) return showToast('Render & extract first');
  const fw     = $('.sw[data-fw].active')?.dataset.fw || 'selenium';    // selenium | playwright
  const runner = $('.sw[data-runner].active')?.dataset.runner || 'testng'; // testng | cucumber
  const lang   = $('.sw[data-lang].active')?.dataset.lang || 'java';    // java | javascript | python | typescript

  const res = buildArtifacts({fw, runner, lang, locs: CURRENT_LOCATORS});
  output.value = `// ===== POM =====\\n${res.pom}\\n\\n// ===== Steps =====\\n${res.steps}`;
  showToast('POM + Steps generated');
});

/* ---------- Artifact Builders ---------- */
function buildArtifacts({fw, runner, lang, locs}){
  if(lang==='java'){
    if(fw==='selenium') return javaSeleniumArtifacts(runner, locs);
    else return javaPlaywrightArtifacts(runner, locs);
  }
  if(lang==='javascript') return jsPlaywrightArtifacts(locs);
  if(lang==='typescript') return tsPlaywrightArtifacts(locs);
  if(lang==='python')     return pyPlaywrightArtifacts(locs);
  return {pom:'// Unsupported', steps:''};
}

function javaSeleniumArtifacts(runner, locs){
  const fields = locs.map((l,i)=>`  @FindBy(xpath = "${(l.xpaths.sfsmart||l.xpaths.sf||l.xpaths.pegasmart||l.xpaths.pega||l.xpaths.functions||l.xpaths.wildcards||l.xpaths.axes||l.xpaths.basic).replace(/"/g,'\\"')}")\n  private WebElement el${i+1};`).join('\n\n');
  const actions = locs.map((l,i)=>`  public void clickEl${i+1}(){ ensureClickable(el${i+1}); el${i+1}.click(); }`).join('\n');
  const waits = `
  private WebDriver driver;
  private WebDriverWait wait;
  public SamplePage(WebDriver driver){
    this.driver = driver;
    PageFactory.initElements(driver, this);
    this.wait = new WebDriverWait(driver, Duration.ofSeconds(10));
  }
  private void ensureVisible(WebElement e){ wait.until(ExpectedConditions.visibilityOf(e)); }
  private void ensureClickable(WebElement e){ wait.until(ExpectedConditions.elementToBeClickable(e)); }`;

  const pom = `import org.openqa.selenium.*; 
import org.openqa.selenium.support.FindBy;
import org.openqa.selenium.support.PageFactory;
import org.openqa.selenium.support.ui.*;
import java.time.Duration;

public class SamplePage {
${fields}

${waits}

${actions}
}
`;

  const steps = (runner==='cucumber')
    ? `import io.cucumber.java.en.*;\nimport org.openqa.selenium.*;\n\npublic class Steps {\n  private WebDriver driver;\n  private SamplePage page;\n  @Given("I open the app") public void open(){ /* driver init */ page = new SamplePage(driver); }\n  @When("I click first element") public void c1(){ page.clickEl1(); }\n  @Then("I see result") public void see(){ /* assert */ }\n}\n`
    : `import org.openqa.selenium.*;\nimport org.testng.annotations.*;\n\npublic class TestSample {\n  private WebDriver driver;\n  private SamplePage page;\n  @BeforeClass public void setup(){ /* init driver */ page = new SamplePage(driver); }\n  @Test public void t1(){ page.clickEl1(); }\n  @AfterClass public void cleanup(){ if(driver!=null) driver.quit(); }\n}\n`;

  return {pom, steps};
}

function javaPlaywrightArtifacts(runner, locs){
  const fields = locs.map((l,i)=>`  private Locator el${i+1};`).join('\n');
  const init   = locs.map((l,i)=>`    el${i+1} = page.locator("${(l.playwright||'').replace(/"/g,'\\"') || (l.xpaths.basic? `xpath=${l.xpaths.basic.replace(/"/g,'\\"')}` : 'css=*')}");`).join('\n');
  const actions= locs.map((l,i)=>`  public void clickEl${i+1}(){ el${i+1}.click(); }`).join('\n');

  const pom = `import com.microsoft.playwright.*;\n\npublic class PwPage {\n  private Page page;\n${fields}\n  public PwPage(Page page){\n    this.page = page;\n${init}\n  }\n${actions}\n}\n`;
  const steps = `// create BrowserType.LaunchOptions etc., then new PwPage(page) and call actions`;
  return {pom, steps};
}

function jsPlaywrightArtifacts(locs){
  const fields = locs.map((l,i)=>`  const el${i+1} = page.locator(\`${l.playwright || (l.xpaths.basic? 'xpath=' + l.xpaths.basic : 'css=*')}\`);`).join('\n');
  const pom = `// JS Playwright sample\nmodule.exports.test = async ({ page }) => {\n${fields}\n  await el1.click();\n};\n`;
  return {pom, steps:''};
}
function tsPlaywrightArtifacts(locs){
  const fields = locs.map((l,i)=>`  const el${i+1} = page.locator(\`${l.playwright || (l.xpaths.basic? 'xpath=' + l.xpaths.basic : 'css=*')}\`);`).join('\n');
  const pom = `// TS Playwright sample\nexport async function test(page: import('@playwright/test').Page){\n${fields}\n  await el1.click();\n}\n`;
  return {pom, steps:''};
}
function pyPlaywrightArtifacts(locs){
  const fields = locs.map((l,i)=>`    el${i+1} = page.locator("${l.playwright || (l.xpaths.basic? 'xpath=' + l.xpaths.basic : 'css=*')}")`).join('\n');
  const pom = `# Python Playwright sample\ndef test_example(page):\n${fields}\n    el1.click()\n`;
  return {pom, steps:''};
}

/* =========================
   API Studio (unchanged minimal)
========================= */
$('#btnGenerateApi')?.addEventListener('click', ()=>{
  const method = $('#apiMethod')?.value || 'GET';
  const url    = $('#apiUrl')?.value || '';
  const headers= $('#apiHeaders')?.value || '';
  const body   = $('#apiBody')?.value || '';
  const code = `// RestAssured\ngiven().headers(${headers||'{}'}).body(${body||'null'}).when().${method.toLowerCase()}("${url}").then().statusCode(200);`;
  $('#apiCode').value = code;
  showToast('API code generated');
});

/* =========================
   Utils
========================= */
function downloadBlob(blob, filename){
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = filename;
  document.body.appendChild(a); a.click();
  setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
}

setMode('pom'); // default
</script>
